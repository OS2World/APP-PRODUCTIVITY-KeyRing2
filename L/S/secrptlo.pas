{***************************************************************************
* Filename: ~modname~
* Version:  ~version~
* Date:     ~date~ @ ~time~
* Group:    ~group~
* Release:  ~release~
* ----------------------------
*
* Modifications
* -------------
*
* Version   Date     Time    Programmer   Description
* ~log~
*
*
* ~notes~
* Description
* -----------
* Low level, generic crypter object
*
*
* The TextCrypt object creates a file with the following structure:
*
* Header of type CryptHead - fixed size record
* Block of Grundge - block length = 0 - 255 bytes, filled with random junk
* LineRec - small fixed size record that controls line
* Line - variable length
* LineRec
* Line
* ...
*
* The contents of Header (other than ID, and Vers) is encrypted and has many
* decoy values that do nothing. The header keeps track of all global
* information in the file such as:
*   ID            : The clear text signature of the file
*   Vers          : Version of crypter - clear longint
*
*   (following fields use various encryption methods)
*
*   PubKey        : CRC of text key used to encrypt
*   FILESIZE      : True size of file
*   DataBlockOfst : first byte of actual data - skip grundge
*   CrcChecksum   : checksum of grundge + data
*   Spare         : for future expansion - random longint
*   Spare1        : for future expansion - random longint
*   Spare2        : for future expansion - random longint
*
*   All Header fields with a Dummyx name are decoys containing random values
*
* Some ramblings on how this crazy thing works:
*
* The variable sized Grundge block length can be skipped over by decrypting
* Head.DataBlockOfst and SEEKing into the file that amount.
*
* Each LineRec contains an encrypted Strategy flag, that tells the parser
* how to decrypt the current line.  There are currently 4 different secondary
* encryption strategies.  The LineRec contains the encrypted length of the
* associated line and either one or two (depending on strategy) dummy random
* bytes.  Strategies are selected randomly and automatically at encryption
* time.
*
* The baseline encryption scheme is a long sequence (>= file length) of random
* characters that are sequentially XORed with each clear text character. The
* sequence is determined by seeding the TP random number generator with the
* CRC of the individual characters of both a PublicKeyString and a
* PrivateKeyString. This creates a single 16 bit seed.  During decryption,
* the unknown public key partial seed value is read from the encrypted file
* header and is combined with the known private key CRC.
*
* Decryption involves seeding the random number generator with exactly the
* same seed to create the same sequence, and then repeating the XOR process
* to recover the original data.  There are 65,535 possible keys, but the
* "slippery rock" file format, with variable length records and multiple
* secondary encryption methods effectivly amplifies this number.
*
* Since the key never repeats, this is esentially a one-time-pad encryption
* scheme that is virtually impossible to break by external means.  The
* complexity of this algorithm is to make reverse engineering by disassembly
* a daunting task.
*
* There is no termination flag for the lines of text - just keep reading
* lines until getline returns false.
*
* The read (decrypt) initialization method does a CRC checksum of the Grundge
* block plus all of the LineRecs and Lines.  It stops doing CRC checksumming
* at the last byte of the last line in the file.  This allows encrypted files
* to be transfered using XMODEM and other primative file transfer protocols
* that round up the number of bytes in a file to some power of two blocksize.
*
* The CRC step will also check the integrity of the file against hacking,
* disk sector cross linking and partial overwrites.
*
* Since the encrypted files generated by this algorithm are esentially random,
* they won't LHarc or ZIP worth a flip.  Don't bother as they will just get
* bigger after "compression"
*
* For best security, use a public key based on the current date/time.
* The private key can be any string known to both the crypter and the
* application that must decrypt it.  Keys are case sensitive!
*
* The keylength should be greater than the number of bytes to crypt, should
* be the same for both crypter and decrypter (in case it is not greater than
* data length :-) ).  The keylength affects the memory usage of the
* algorithm, so don't get carried away with enormous keys.
*
* This is not the same algorithm used by NENMAIL.
*
*
* ~notesend~
* ~nokeywords~
*
****************************************************************************

}
{$A+,B-,D+,E+,F+,G+,I+,L+,N-,O+,P-,Q+,T-,V-,X+,Y+}

UNIT SECRPTLO;

INTERFACE
USES
    Dos,
    SEBUFF,
    OpRoot;

CONST
    MAXCRYPTBUF    = $7F;         {max string length}
    CRYPTIDMAX     = 11;
    SECCOMMENTLEN  = 82;
TYPE
    KeyArray       = ARRAY[0..$FFFE] OF BYTE;
    KeyPtr         = ^KeyArray;
    TCryptBufP     = ^KeyArray;

    {CryptLo is an object used to derive new Text and Binary encryption object}
    CryptLoPtr     = ^CryptLo;
    CryptLo        = OBJECT(BufferedFileT)
                         CONSTRUCTOR Init;

                         {CONSTRUCTOR InitPub(KeyLength, PubKey : WORD; PrivKey : STRING);}
                         DESTRUCTOR Done; VIRTUAL;

                         FUNCTION CryptBuf(Buffer : TCryptBufP; NumBytes : WORD) : TCryptBufP;
                         FUNCTION BuildKey(KeyLength : WORD; PubKey, PrivKey : STRING) : BOOLEAN;
                         FUNCTION BuildKeyPub(KeyLength, PubKey : WORD; PrivKey : STRING) : BOOLEAN;
                         FUNCTION MakeRandLong : LONGINT;

                     PRIVATE

                         Rotor          : WORD;
                         DeadMan        : LONGINT;
                         Key            : KeyPtr;
                         KeyLen         : WORD;

                         PROCEDURE IncrementRotor;
                         FUNCTION XORWithKey(B : BYTE) : BYTE;

                             {$IFDEF DEBUG_RAND}
                         FUNCTION ChiSquare:REAL;
                         {$ENDIF}
                     END;

TYPE
    FourByteRec    = RECORD
                         B1,
                         B2,
                         B3,
                         B4             : BYTE;
                     END;

    {method of secondary encryption, selected at random by crypter}
    TStrategy      = (ESecondXOR, ECharOffset, EReverse, EPairSwap);

    {a formidible looking header to be prepended to crypted text}
    CryptHead      = RECORD
                         ID             : ARRAY[1..CRYPTIDMAX] OF CHAR;
                         Comment        : ARRAY[1..SECCOMMENTLEN] OF CHAR;
                         Vers,    {crypter version}
                         Dummy1         : LONGINT;
                         PubKey         : WORD; {public key}
                         Dummy2,
                         FILESIZE,
                         DataBlockOfst, {first byte of actual data}
                         Dummy3         : LONGINT;
                         CrcChecksum    : WORD;
                         Dummy4,
                         Spare,
                         Spare1,
                         Spare2         : LONGINT;
                     END;

    CryptMode      = (EREAD, EWRITE, EERROR);

    (****************************************************************************)

    {Header for each line of crypted text}
    LineRec        = RECORD
                         Len            : BYTE; {xored w/ key}
                         Strategy       : TStrategy; {xored w/ key}
                         Spare1,  {random}
                         Spare2         : BYTE; {random}
                     END;

    {A textcrypt object is used to encrypt/decrypt 127 byte max strings and }
    {put them in a binary file                                              }

    {This object has 4 different encryption strategies, selected at random  }
    {at encryption time.  The decrypter detects the strategy used and acts  }
    {accordingly                                                            }

    TextCryptPtr   = ^TextCrypt;
    TextCrypt      = OBJECT(CryptLo)
                         CONSTRUCTOR WriteInit(FName,
                                               CryptID,
                                               PubKey,
                                               PrivKey        : STRING;
                                               KeyLength      : WORD;
                                               CryptVer       : LONGINT;
                                               Comment        : STRING);
                         CONSTRUCTOR ReadInit(FName,
                                              CryptID,
                                              PrivKey        : STRING;
                                              KeyLength      : WORD;
                                              CryptVer       : LONGINT;
                                              VAR Comment    : STRING);
                         DESTRUCTOR Done; VIRTUAL;
                         FUNCTION GetLine(VAR L : STRING) : BOOLEAN;
                         FUNCTION PutLine(L : STRING) : BOOLEAN;
                         FUNCTION CryptStat : BOOLEAN;
                         FUNCTION GetLastError : WORD;
                         PROCEDURE FSeek(P : LONGINT);

                     PRIVATE

                         TF             : TEXT;
                         CurFName       : PathStr;
                         CurMode        : CryptMode;
                         CurCryptID     : STRING[CRYPTIDMAX - 1];
                         CurCryptVer    : LONGINT;
                         Buff           : TCryptBufP;
                         DataLen        : BYTE;
                         IsCrypted      : BOOLEAN;
                         Spare          : LONGINT;

                         FUNCTION FieldLen(VAR LR : LineRec) : CHAR;
                         FUNCTION SecondXOR(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
                         FUNCTION CharOffset(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
                         FUNCTION Reverse(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
                         FUNCTION PairSwap(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
                         FUNCTION CalcFileCrc(VAR Head : CryptHead) : WORD;
                         FUNCTION TwiddleLong(L : LONGINT) : LONGINT;
                     END;

FUNCTION DecryptConst(CRP : PCHAR; PubKey, PrivKey : WORD) : STRING;
FUNCTION DecodeStrg(S : STRING; PubKey, PrivKey : WORD) : STRING;


    (****************************************************************************)

IMPLEMENTATION

USES
    ApMisc,
    Crc,
    UTIAM,
    OpConst,
    OpDos,
    OpInline,
    OpString,
    Strings,
    {$IFDEF ZILCH}
    UERROR;
    {$ELSE}
    KERROR;
    {$ENDIF}

    (****************************************************************************)

    {Decrypts a string constant array, returning the string on the stack   }
    {CRP is a pointer to the Crypted array; PubKey is the N seed value,    }
    {and PrivKey is the secondary XOR value (see above) for more details   }
    {Calling syntax:  Strg := DecryptConst(@CRYPT1S, CRYPT1N, CRYPT1P);    }
    {   It is probably a good idea to store the PrivKey in a dongle or     }
    {   calculate it just prior to use.                                    }

    FUNCTION DecryptConst(CRP : PCHAR; PubKey, PrivKey : WORD) : STRING;
    VAR
        I              : BYTE;
        T              : PCHAR;
    BEGIN
        DecryptConst := '';

        GetMemCheck(T, $FF);      {get enough memory for a max length string}
        IF T = NIL THEN           {bail on no mem avail }
            EXIT;

        FILLCHAR(T^, $FF, 0);
        {reset the counter}
        I := 0;

        RANDSEED := PubKey;

        REPEAT
            {begin decrypting the array}
            T[I] := CHAR(ORD(CRP[I]) XOR RANDOM($FF) XOR PrivKey);
            {inc the counter}
            INC(I);
        UNTIL T[I - 1] = #0;      {quit when null termchar is reached}
        {translate ASCIIZ to pascal string}
        DecryptConst := StrPas(T);

        {clear and deallocate the heap buffer}
        FILLCHAR(T^, $FF, #0);
        FreeMemCheck(T, $FF);
        T := NIL;
    END;

    {--------------}

    {Function very similar to the one above, with the exception that untyped}
    {constants can be used for the input string, avoiding the use of dgroup }
    FUNCTION DecodeStrg(S : STRING; PubKey, PrivKey : WORD) : STRING;
    VAR
        Strg           : STRING;
        I              : BYTE;
        ORS            : LONGINT;
    BEGIN
        ORS := RANDSEED;
        RANDSEED := PubKey;
        Strg[0] := S[0];
        FOR I := 1 TO LENGTH(S) DO
            Strg[I] := CHAR(ORD(S[I]) XOR RANDOM($FF) XOR PrivKey);
        DecodeStrg := Strg;
        RANDSEED := ORS;
    END;

    {--------------}

    CONSTRUCTOR CryptLo.Init;
    BEGIN
        IF NOT BufferedFileT.Init(8000) THEN
            FAIL;

        Key := NIL;
        KeyLen := 0;
        Rotor := 0;
        DeadMan := 0;
    END;

    (****************************************************************************)

    FUNCTION CryptLo.BuildKey(KeyLength : WORD; PubKey, PrivKey : STRING) : BOOLEAN;
    VAR
        I,
        J              : WORD;
    BEGIN
        BuildKey := FALSE;

        IF Key <> NIL THEN
            FreeMemCheck(Key, KeyLen);

        KeyLen := KeyLength;

        IF NOT GetMemCheck(Key, KeyLen) THEN BEGIN
            InitStatus := epFatal + ecOutOfMemory;
            EXIT;
        END;

        J := 0;

        FOR I := 1 TO LENGTH(PubKey) DO
            CalcCRC(ORD(PubKey[I]), J);

        FOR I := 1 TO LENGTH(PrivKey) DO
            CalcCRC(ORD(PrivKey[I]), J);

        RANDSEED := J;

        FOR I := 0 TO KeyLength - 1 DO
            Key^[I] := BYTE(RANDOM($FF));

        Rotor := 0;

        {$IFDEF DEBUG_RAND}
        WRITELN(ChiSquare);
        {$ENDIF}
        BuildKey := TRUE;

    END;

    (****************************************************************************)

    FUNCTION CryptLo.BuildKeyPub(KeyLength, PubKey : WORD; PrivKey : STRING) : BOOLEAN;
    VAR
        I,
        J              : WORD;
    BEGIN

        BuildKeyPub := FALSE;

        KeyLen := KeyLength;

        IF NOT GetMemCheck(Key, KeyLen) THEN BEGIN
            InitStatus := epFatal + ecOutOfMemory;
            EXIT;
        END;
        Key := Normalized(Key);

        J := PubKey;

        FOR I := 1 TO LENGTH(PrivKey) DO
            CalcCRC(ORD(PrivKey[I]), J);

        RANDSEED := J;

        FOR I := 0 TO KeyLength - 1 DO
            Key^[I] := RANDOM(255);

        Rotor := 0;

        {$IFDEF DEBUG_RAND}
        WRITELN(ChiSquare);
        {$ENDIF}
        BuildKeyPub := TRUE;
    END;

    (****************************************************************************)

    FUNCTION CryptLo.XORWithKey(B : BYTE) : BYTE;
    BEGIN
        XORWithKey := B XOR Key^[Rotor];
        IncrementRotor;
    END;

    (****************************************************************************)

    FUNCTION CryptLo.MakeRandLong : LONGINT;
    TYPE
        LongRec        = RECORD
                             H,
                             L              : WORD;
                         END;
    VAR
        L              : LONGINT;
        HL             : LongRec ABSOLUTE L;
    BEGIN
        HL.L := RANDOM($FFFF);
        HL.H := RANDOM($FFFF);
        MakeRandLong := L;
        L := 0;
    END;

    (****************************************************************************)

    DESTRUCTOR CryptLo.Done;
    VAR
        I              : WORD;
    BEGIN
        INHERITED Done;
        Rotor := 0;
        DeadMan := 0;

        IF Key <> NIL THEN BEGIN
            FILLCHAR(Key^, KeyLen, #0);
            FreeMemCheck(Key, KeyLen);
        END;

        Key := NIL;
        KeyLen := 0;
    END;

    (****************************************************************************)

    FUNCTION CryptLo.CryptBuf(Buffer : TCryptBufP; NumBytes : WORD) : TCryptBufP;
    VAR
        I              : WORD;
    BEGIN
        FOR I := 0 TO NumBytes DO
            Buffer^[I] := XORWithKey(Buffer^[I]);
        CryptBuf := Buffer;
    END;

    (****************************************************************************)

    {bump to next avail key or wrap around}
    PROCEDURE CryptLo.IncrementRotor;
    BEGIN
        INC(Rotor);
        Rotor := Rotor MOD KeyLen;
    END;

    (****************************************************************************)
    {$IFDEF DEBUG_RAND}

    {- This method checks the randomness of the key sequence}
    {- The return value should be within +-2*SQRT(255) OF 255 (+- 31.9)}

    FUNCTION CryptLo.ChiSquare:REAL;
    VAR
        T : REAL;
        I : WORD;
        TAP : KeyPtr;
    BEGIN
        ChiSquare := -1.0;

        IF NOT GetMemCheck(TAP, KeyLen) THEN
            EXIT;

        FILLCHAR(TAP^, KeyLen, 0);

        FOR I := 0 TO KeyLen DO
            INC(TAP^[Key^[I]]);

        T := 0.0;
        FOR I:=0 TO KeyLen-1 DO
            T := T+TAP^[I]*TAP^[I];

        ChiSquare := ((255.0 * T/KeyLen)-KeyLen);
        FreeMemCheck(TAP, KeyLen);
        TAP := NIL;
    END;
    {$ENDIF}

    (****************************************************************************)

    FUNCTION TextCrypt.TwiddleLong(L : LONGINT) : LONGINT;
    VAR
        Fbr            : FourByteRec ABSOLUTE L;
    BEGIN
        Fbr.B1 := Fbr.B1 XOR $11;
        Fbr.B2 := Fbr.B2 XOR $10;
        Fbr.B3 := Fbr.B3 XOR $54;
        Fbr.B4 := Fbr.B4 XOR $AB;
        TwiddleLong := L;
        L := 0;
    END;

    (****************************************************************************)

    {return length of current string in buffer.  Warning: This is a state machine}
    {that will be disturbed if called more than once per buffer load             }
    FUNCTION TextCrypt.FieldLen(VAR LR : LineRec) : CHAR;
    VAR
        L              : BYTE;
    BEGIN
        L := XORWithKey(LR.Len);

        CASE LR.Strategy OF
            ESecondXOR : L := L XOR LR.Spare2;
            ECharOffset : L := L - LR.Spare1;
            EReverse : ;
            EPairSwap : ;
        END;
        LR.Len := L;
        FieldLen := CHAR(L);
    END;

    (****************************************************************************)

    {- secondary encryption strategy function}
    {- after xor with key, do second xor with line header spare2 value}
    FUNCTION TextCrypt.SecondXOR(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
    VAR
        I              : BYTE;
        Result         : WORD;
    BEGIN
        CASE Mode OF
            EREAD :
                BEGIN
                    SecondXOR := FALSE;
                    L[0] := FieldLen(LR);
                    IF LR.Len > 0 THEN BEGIN
                        bBLOCKREAD(Buff^, ORD(L[0]), Result);
                        IF Result <> ORD(L[0]) THEN
                            EXIT;

                        FOR I := 1 TO LENGTH(L) DO
                            L[I] := CHAR((XORWithKey(Buff^[I - 1])) XOR LR.Spare2);
                    END;
                    SecondXOR := TRUE;
                END;
            EWRITE :
                BEGIN
                    DataLen := LR.Len;
                    LR.Len := XORWithKey(LR.Len XOR LR.Spare2);
                    FOR I := 1 TO LENGTH(L) DO
                        Buff^[I - 1] := XORWithKey(ORD(L[I]) XOR LR.Spare2);
                    SecondXOR := TRUE;
                END;
        END;
    END;

    (****************************************************************************)

    {- secondary encryption strategy function}
    {- after xor with key, do additive / subtractive char offset with spare1 value}
    FUNCTION TextCrypt.CharOffset(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
    VAR
        I              : BYTE;
        Result         : WORD;
        A,
        B              : SHORTINT;
    BEGIN
        CASE Mode OF
            EREAD :
                BEGIN
                    CharOffset := FALSE;
                    L[0] := FieldLen(LR);
                    IF LENGTH(L) > 0 THEN BEGIN
                        bBLOCKREAD(Buff^, ORD(L[0]), Result);
                        IF Result <> ORD(L[0]) THEN
                            EXIT;
                        FOR I := 1 TO LENGTH(L) DO BEGIN
                            L[I] := CHAR(XORWithKey(Buff^[I - 1]));
                            L[I] := CHAR(ORD(L[I]) - LR.Spare1);
                        END;
                    END;
                    CharOffset := TRUE;
                END;
            EWRITE :
                BEGIN
                    DataLen := LR.Len;
                    LR.Len := XORWithKey(LENGTH(L) + LR.Spare1);
                    FOR I := 1 TO LENGTH(L) DO
                        Buff^[I - 1] := XORWithKey(ORD(L[I]) + LR.Spare1);
                    CharOffset := TRUE;
                END;
        END;                      {case}
    END;

    (****************************************************************************)

    {- secondary encryption strategy function}
    {- after xor with key, reverse direction of string, making a mirror image}
    FUNCTION TextCrypt.Reverse(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
    VAR
        Strg           : STRING;
        I,
        J              : BYTE;
        Result         : WORD;
    BEGIN
        CASE Mode OF
            EREAD :
                BEGIN
                    L[0] := FieldLen(LR);
                    Reverse := FALSE;
                    IF LR.Len > 0 THEN BEGIN
                        bBLOCKREAD(Buff^, ORD(L[0]), Result);
                        IF Result <> ORD(L[0]) THEN
                            EXIT;
                        Strg := '';
                        J := 0;
                        FOR I := LENGTH(L) DOWNTO 1 DO BEGIN
                            L[I] := CHAR(XORWithKey(Buff^[J]));
                            INC(J);
                        END;
                    END;
                    Reverse := TRUE;
                END;
            EWRITE :
                BEGIN
                    DataLen := LR.Len;
                    LR.Len := XORWithKey(LR.Len);
                    J := 0;
                    FOR I := LENGTH(L) DOWNTO 1 DO BEGIN
                        Buff^[J] := XORWithKey(ORD(L[I]));
                        INC(J);
                    END;
                END;
        END;                      {case}
        FILLCHAR(Strg, SIZEOF(Strg), #0);
    END;

    (****************************************************************************)

    {- secondary encryption strategy function}
    {- after xor with key, swap adjacent character pairs}
    FUNCTION TextCrypt.PairSwap(Mode : CryptMode; VAR L : STRING; VAR LR : LineRec) : BOOLEAN;
    VAR
        Strg           : STRING;
        Temp           : CHAR;
        I              : BYTE;
        Result         : WORD;
    BEGIN
        CASE Mode OF
            EREAD :
                BEGIN
                    L[0] := FieldLen(LR);
                    Strg := '';
                    PairSwap := FALSE;
                    IF LR.Len > 0 THEN BEGIN
                        bBLOCKREAD(Buff^, ORD(L[0]), Result);
                        IF Result <> ORD(L[0]) THEN
                            EXIT;
                        FOR I := 1 TO LENGTH(L) DO BEGIN
                            L[I] := CHAR(XORWithKey(Buff^[I - 1]));
                            Strg := Strg + L[I];
                        END;
                        I := 1;
                        WHILE I < LENGTH(Strg) DO BEGIN
                            Temp := Strg[I];
                            Strg[I] := Strg[I + 1];
                            Strg[I + 1] := Temp;
                            INC(I, 2);
                        END;
                    END;
                    L := Strg;
                    PairSwap := TRUE;
                END;
            EWRITE :
                BEGIN
                    DataLen := LR.Len;
                    LR.Len := XORWithKey(LENGTH(L));
                    I := 1;
                    WHILE I < LENGTH(L) DO BEGIN
                        Temp := L[I];
                        L[I] := L[I + 1];
                        L[I + 1] := Temp;
                        INC(I, 2);
                    END;

                    FOR I := 1 TO LENGTH(L) DO BEGIN
                        Buff^[I - 1] := XORWithKey(ORD(L[I]));
                    END;
                END;
        END;                      {case}
        FILLCHAR(Strg, SIZEOF(Strg), #0);
    END;

    (****************************************************************************)

    {- init the TextCrypter for write (key file generation) }
    CONSTRUCTOR TextCrypt.WriteInit(FName,
                                    CryptID,
                                    PubKey,
                                    PrivKey        : STRING;
                                    KeyLength      : WORD;
                                    CryptVer       : LONGINT;
                                    Comment        : STRING);
    VAR
        I,
        J,
        Result         : WORD;
        Head           : CryptHead;
        Strg           : STRING;
        FoundTO        : BOOLEAN;
        GrundgeBuf     : TCryptBufP;
        Fbr            : FourByteRec ABSOLUTE Spare;
        L              : LONGINT;
    BEGIN

        IF NOT CryptLo.Init THEN
            FAIL;

        IF NOT CryptLo.BuildKey(KeyLength, PubKey, PrivKey) THEN
            FAIL;

        CurFName := FName;
        CurMode := EWRITE;

        IF NOT GetMemCheck(Buff, MAXCRYPTBUF) THEN BEGIN
            CryptLo.Done;
            InitStatus := epFatal + ecOutOfMemory;
            FAIL;
        END;

        FILLCHAR(Head, SIZEOF(Head), 0);

        {truncate ID if necessary, makes it a asciiz string}
        IF LENGTH(CryptID) > SIZEOF(Head.ID) - 1 THEN
            CryptID[0] := CHAR(SIZEOF(Head.ID) - 1);

        MOVE(CryptID[1], Head.ID, LENGTH(CryptID));
        Head.Vers := CryptVer;
        J := 0;

        RANDOMIZE;
        Head.Dummy3 := MakeRandLong;

        FOR I := 1 TO LENGTH(PubKey) DO
            CalcCRC(ORD(PubKey[I]), J);

        Head.Dummy1 := MakeRandLong;
        Head.Dummy2 := MakeRandLong;
        Head.PubKey := J;
        Head.Dummy4 := MakeRandLong;
        Head.Spare := MakeRandLong;
        Head.Spare1 := MakeRandLong;
        Head.Spare2 := MakeRandLong;

        Spare := MakeRandLong;
        Fbr.B3 := Fbr.B3 MOD $7F; {make sure we dont wrap in offset strategy}
        Head.Spare := Spare;
        RANDOMIZE;
        Head.DataBlockOfst := TwiddleLong(SIZEOF(Head) + RANDOM($FF));

        FOR I := 1 TO SECCOMMENTLEN DO
            Head.Comment[I] := CHAR(RANDOM($FF));

        Comment := ^M^J + Comment + ^Z;

        IF LENGTH(Comment) > SECCOMMENTLEN THEN BEGIN
            Comment[0] := CHAR(SECCOMMENTLEN - 1);
            Comment := Comment + ^Z;
        END;

        MOVE(Comment[1], Head.Comment, LENGTH(Comment));

        bASSIGN(FName);
        Result := bIORESULT;
        {$I-}
        bREWRITE;

        Result := bIORESULT;
        IF Result <> 0 THEN BEGIN
            InitStatus := Result;
            FAIL;
        END;
        {$I+}
        {write the header}
        bBLOCKWRITE(Head, SIZEOF(Head), Result);

        IF Result <> SIZEOF(Head) THEN BEGIN
            bCLOSE;
            CryptLo.Done;
            FILLCHAR(Head, SIZEOF(Head), 0);
            InitStatus := epFatal + ecDiskFull;
            FAIL;
        END;

        GrundgeBuf := NIL;

        {calc size of grundge block - 0 to 255 bytes}
        I := TwiddleLong(Head.DataBlockOfst) - SIZEOF(Head);
        IF I > 0 THEN BEGIN
            IF NOT GetMemCheck(GrundgeBuf, I) THEN BEGIN
                CryptLo.Done;
                InitStatus := epFatal + ecOutOfMemory;
                FAIL;
            END;

            {fill grundge block with random crap}
            FOR J := 0 TO I - 1 DO
                GrundgeBuf^[J] := RANDOM($FF);

            {write a random length block of crap}
            bBLOCKWRITE(GrundgeBuf^, I, Result);
            IF I <> Result THEN BEGIN
                CryptLo.Done;
                FreeMemCheck(GrundgeBuf, I);
                GrundgeBuf := NIL;
                InitStatus := epFatal + ecDiskFull;
                FAIL;
            END;

            {FILLCHAR(GrundgeBuf^, I, #0);}

            FreeMemCheck(GrundgeBuf, I);
            GrundgeBuf := NIL;
        END;
        {BF file pointer points to first valid data byte in crypted file}
        IsCrypted := TRUE;

    END;

    (****************************************************************************)

    {opens file for read, calculates crc of grundge+data, moves fp to }
    {first byte of data, leaves file open                             }

    FUNCTION TextCrypt.CalcFileCrc(VAR Head : CryptHead) : WORD;
    CONST
        CrcBlockReadSize = 8192;
    VAR
        I,
        Result,
        CrcResult      : WORD;
        GrundgeBuf     : TCryptBufP;
        Strg           : STRING;
        BytesRead      : LONGINT;
    BEGIN
        CalcFileCrc := 0;
        {$I-}

        Result := bIORESULT;
        bASSIGN(CurFName);
        bRESET(0);
        Result := bIORESULT;
        IF Result <> 0 THEN
            EXIT;
        bBLOCKREAD(Head, SIZEOF(CryptHead), Result);
        {$I+}
        Strg := StrPas(@Head.ID);

        IsCrypted := (Strg = CurCryptID) AND (Head.Vers = CurCryptVer);
        FILLCHAR(Strg, SIZEOF(Strg), #0);
        Result := bIORESULT;

        CrcResult := 0;

        IF NOT GetMemCheck(GrundgeBuf, CrcBlockReadSize) THEN
            EXIT;

        GrundgeBuf := Normalized(GrundgeBuf);

        Head.FILESIZE := TwiddleLong(Head.FILESIZE);

        {calc file crc, grundge + data (no header crc)}
        BytesRead := 0;
        REPEAT
            bBLOCKREAD(GrundgeBuf^, CrcBlockReadSize, Result);
            {Trap any extra crap tagged on to the end of the file.}
            {Unsophisticated users may use XMODEM to do file transfer}
            {of crypted file, appending XMODEM block pad chars to end of file}
            IF Result > 0 THEN
                FOR I := 0 TO Result - 1 DO BEGIN
                    CalcCRC(GrundgeBuf^[I], CrcResult);
                    INC(BytesRead);
                    IF BytesRead = Head.FILESIZE THEN
                        BREAK;
                END;
        UNTIL (Result <> CrcBlockReadSize) OR (BytesRead = Head.FILESIZE);

        FILLCHAR(GrundgeBuf^, CrcBlockReadSize, #0);

        FreeMemCheck(GrundgeBuf, CrcBlockReadSize);
        GrundgeBuf := NIL;
        bSEEK(TwiddleLong(Head.DataBlockOfst)); {move to start of data}
        CalcFileCrc := CrcResult;
    END;

    (****************************************************************************)

    {P=0 seeks first line of file - This really only works for seek to head}
    {of file                                                               }
    PROCEDURE TextCrypt.FSeek(P : LONGINT);
    VAR
        Head           : CryptHead;
        Result         : WORD;
    BEGIN
        Rotor := P MOD KeyLen;    {resync the key}
        bSEEK(0);
        bBLOCKREAD(Head, SIZEOF(Head), Result);
        bSEEK(TwiddleLong(Head.DataBlockOfst) + P);
        FILLCHAR(Head, SIZEOF(Head), #0);
    END;

    (****************************************************************************)

    {- Init the TextCrypter for read (decryption) of the key file}
    {- Bail out if anything in the key file smells bad           }
    CONSTRUCTOR TextCrypt.ReadInit(FName,
                                   CryptID,
                                   PrivKey        : STRING;
                                   KeyLength      : WORD;
                                   CryptVer       : LONGINT;
                                   VAR Comment    : STRING);
    VAR
        I,
        CrcResult,
        Result         : WORD;
        Head           : CryptHead;
        {Strg           : STRING;}
    BEGIN
        Buff := NIL;
        {make sure the file exists and no pathological parameters got passed}
        IF LENGTH(FName) = 0 THEN BEGIN
            InitStatus := epFatal + ecFileNotFound;
            FAIL;
        END;

        IF (LENGTH(PrivKey) = 0) OR (LENGTH(CryptID) = 0) THEN BEGIN
            InitStatus := epFatal + ecFieldRequired;
            FAIL;
        END;

        IF NOT ExistFile(FName) THEN BEGIN
            InitStatus := epFatal + ecFileNotFound;
            FAIL;
        END;

        CurFName := FName;
        CurMode := EREAD;
        CurCryptID := CryptID;
        CurCryptVer := CryptVer;

        {create the random key sequence}
        IF NOT CryptLo.Init THEN BEGIN
            FreeMemCheck(Buff, MAXCRYPTBUF);
            Buff := NIL;
            FILLCHAR(Head, SIZEOF(Head), #0);
            InitStatus := epFatal + ecOutOfMemory;
            FAIL;
        END;

        {compare calculated crc with header crc}
        {header CRC is not calculated - }
        {Any substantial header tampering will result in gibberish}
        {decryptions however}
        IF CalcFileCrc(Head) <> Head.CrcChecksum THEN BEGIN
            IF InitStatus = 0 THEN
                InitStatus := epFatal + ecCrcError;
            FAIL;
        END;

        IF NOT BuildKeyPub(KeyLength, Head.PubKey, PrivKey) THEN BEGIN
            FILLCHAR(Head, SIZEOF(Head), #0);
            InitStatus := epFatal + ecOutOfMemory;
            FAIL;
        END;

        IF NOT IsCrypted THEN BEGIN
            {has invalid or slightly hacked header}
            InitStatus := epFatal + ecFileIsEmpty;
            FAIL;
        END;

        {allocate a single line buffer for file read/write}

        IF NOT GetMemCheck(Buff, MAXCRYPTBUF) THEN BEGIN
            CryptLo.Done;
            InitStatus := epFatal + ecOutOfMemory;
            FAIL;
        END;

        MOVE(Head.Comment, Comment[1], SECCOMMENTLEN - 3);
        FOR I := 1 TO SECCOMMENTLEN DO BEGIN
            Comment[0] := CHAR(I - 1);
            IF Comment[I] = ^Z THEN
                BREAK
        END;
        Comment := Filter(Comment, [#10, #13, #26, #0]);
        FILLCHAR(Head, SIZEOF(Head), #0);
    END;

    (****************************************************************************)

    {- Shut the TextCrypter down - handles both read and write modes}
    DESTRUCTOR TextCrypt.Done;
    VAR
        Head           : CryptHead;
        I,
        CrcResult,
        Result         : WORD;
        FSize          : LONGINT;
        {
        Fbr            : FourByteRec ABSOLUTE FSize;
        B              : BYTE;
        FName          : PathStr;
        }
    BEGIN
        {close file, calc crc checksum and overwrite the header crc field}
        bCLOSE;                   {flush writes}
        CASE CurMode OF
            EWRITE :
                BEGIN
                    {open file for read, read header and calc checksum}
                    Head.CrcChecksum := CalcFileCrc(Head);
                    bRESETRW;
                    FSize := bFileSize - SIZEOF(Head);
                    Head.FILESIZE := TwiddleLong(FSize);
                    {write new checksum}
                    bBLOCKWRITE(Head, SIZEOF(Head), Result);
                    bCLOSE;
                END;
            EREAD :
                BEGIN

                END;
        END;
        {clear internal vars to make memory afterimage harder to hack}
        CurFName := CharStr(' ', SIZEOF(PathStr));
        CurMode := EERROR;
        CurCryptID := CharStr(' ', CRYPTIDMAX - 1);
        CurCryptVer := 0;

        FILLCHAR(Buff^, MAXCRYPTBUF, #0);

        DataLen := 0;
        IsCrypted := FALSE;
        Spare := 0;
        FILLCHAR(Head, SIZEOF(Head), #0);
        CrcResult := 0;
        FSize := 0;
        FreeMemCheck(Buff, MAXCRYPTBUF);
        Buff := NIL;
        CryptLo.Done;
    END;

    (****************************************************************************)

    {- get and decrypt a single line of ascii text}
    {- max line length is 127 chars               }
    FUNCTION TextCrypt.GetLine(VAR L : STRING) : BOOLEAN;
    VAR
        Result         : WORD;
        LR             : LineRec;
    BEGIN
        GetLine := FALSE;
        L := '';
        bBLOCKREAD(LR, SIZEOF(LR), Result);
        IF Result <> SIZEOF(LR) THEN
            EXIT;

        BYTE(LR.Strategy) := BYTE(LR.Strategy) XOR LR.Spare2;
        CASE LR.Strategy OF
            ESecondXOR : GetLine := SecondXOR(EREAD, L, LR);
            ECharOffset : GetLine := CharOffset(EREAD, L, LR);
            EReverse : GetLine := Reverse(EREAD, L, LR);
            EPairSwap : GetLine := PairSwap(EREAD, L, LR);
        END;
        FILLCHAR(LR, SIZEOF(LR), #0);
    END;

    (****************************************************************************)

    {- encrypt and put a single line of ascii text into the key file}
    {- max line length is 127 chars                                 }
    FUNCTION TextCrypt.PutLine(L : STRING) : BOOLEAN;
    VAR
        Result         : WORD;
        LR             : LineRec;
    BEGIN
        PutLine := FALSE;

        LR.Len := LENGTH(L);      {this gets encrypted later}
        LR.Spare1 := RANDOM($7F); {for use as secondary offset}
        LR.Spare2 := RANDOM($FF); {for use as secondary xor}


        {- pick a random secondary encryption strategy for this line}
        LR.Strategy := TStrategy(RANDOM(ORD(HIGH(TStrategy)) + 1));

        CASE LR.Strategy OF
            ESecondXOR : SecondXOR(EWRITE, L, LR);
            ECharOffset : CharOffset(EWRITE, L, LR);
            EReverse : Reverse(EWRITE, L, LR);
            EPairSwap : PairSwap(EWRITE, L, LR);
        END;

        {Write line header}
        BYTE(LR.Strategy) := BYTE(LR.Strategy) XOR LR.Spare2;
        bBLOCKWRITE(LR, SIZEOF(LR), Result);
        IF Result <> SIZEOF(LR) THEN
            EXIT;
        FILLCHAR(LR, SIZEOF(LR), #0);

        {write encrypted line data}
        Result := 0;
        IF DataLen > 0 THEN
            bBLOCKWRITE(Buff^, DataLen, Result);

        FILLCHAR(Buff^, MAXCRYPTBUF, #0);

        PutLine := DataLen = Result;
    END;

    (****************************************************************************)

    FUNCTION TextCrypt.CryptStat : BOOLEAN;
    BEGIN

    END;

    (****************************************************************************)

    FUNCTION TextCrypt.GetLastError : WORD;
    BEGIN

    END;

    (****************************************************************************)


    {unit initialization}

END.                              {of unit SECRPTLO}
(****************************************************************************)
(****************************************************************************)


